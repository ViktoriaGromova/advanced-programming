#include<iostream>

// Some problems related to dynamic dispathing - выбор, какую функцию вызывать в runtime 
// Пусть у двух функций есть свои значения по-умолчанию
struct Base{
    Base(){
        f(0);
    }
    virtual void f(int x = 1) const{
        std::cout << "Base: "<< x << '\n';
    }
};

struct Derived: public Base{
    Derived(){
        f(11);
    }

    void f(int x = 2) const override{
        std::cout << "Derived: " << x << '\n';
    }
};

int main(){
    // Проблема в том, что аргументы по-умолчанию - это compile time концепция
    const Base& b = Derived(); 
    // По идее должен вызваться f от Derived, но вызвалась Derived при x = 1
    // Потому что аргументы по-умолчанию вызываются в compile time, и в этот момент нужно x изначально поставить по-умолчанию
    // И так как мы вызваемся при компиляуии у base, то он в compile time не проверяет наследника, а проверяет от кого вызывается
    // Однако в runtime вызывается функция из Derived
    b.f();

    // Что будет если в конструкторе будт f(1), внутри компилятоа
    b.f(12);
    // На этапе, когда мы вызываемся от Base в констуркции, то вызовется функция от Base, то есть находимся в родиете  и функции, то вызовется функция родителя, так как предок еще не будет создан
    // Base: 0
    // Derived: 11
    // Derived: 1
    // Derived: 12
    // Однако, если в других методах поля Base, то будут создаваться функции от Derived
}