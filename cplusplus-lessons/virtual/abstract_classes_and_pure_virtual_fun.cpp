#include <iostream>
#include <vector>

// Абстрактные классы и чисто виртуальные функции  
// Идея виртуальных функций приводит к идее, если мы хотим создать класс, который будет интерфейсом

// Интерфейс - классы, которые не реализовывают ничего, а только объявляют методы, а все кто от них наследуются
// должны определить эти методы.
// Класс, который выражает концепцию, то есть каждый тип должен иметь тип, частный случай


// Класс у которого есть хотя бы одна виртуальная функция называется абстрактным
// Особенность абстрактных классов - что нельзя создать объкты такого типа


struct Base{
    // pure virtual function
    virtual void f(int) = 0; // То есть мы говорим, что функция чисто виртуальная и не имеет реализации 
    // Но всякий кто будет наследоваться от класс, то он будет считаться абстрактным
};
struct Derived: public Base{
    void f(int) override{
        std::cout << " Der"  <<  std::endl;
    }
};

struct Son: public Base{
    void f(int) override{
        std::cout << "Son"  <<  std::endl;
    }
};

struct Daughter: public Base{
    void f(int) override{
        std::cout << "Daughter"  <<  std::endl;
    }
};

int main(){
    // Base b; // Будет ошибка, так как тут чисто виртуальный метод
    Derived d;
    d.f(0);

    // А если сделать так: взять и по ссылке взять Base
    // Если класс абстрактный, то я могу использовать ссылки и указатели на него.
    // Я могу создавать ссылки на эти объекты, хотя напрямую объекты нельяз создавать
    // Можно создавть вектор на указателей на 
    Base &b = d;
    b.f(0); 

    std::vector<Base*> v;
    v.push_back(new Son());
    v.push_back(new Daughter());

    for(int i = 0; i < v.size(); ++i){ 
        v[i]->f(0);
    }
}