#include <iostream>

// Проблема комбинации виртуальных или не виртупльных функций.

struct Base{
    virtual void f() {std::cout << "Base\n";}
    // А что если мы создадим две функции f, такие что одна виртуальная, а другая нет
    virtual void f(int) {std::cout << "Base_int\n";}
    void f(double) {std::cout << "Base_double\n";}
    // Что будет если в дочернем классе возьмут void f(double) 
    // Ответ -  она не будет виртуальной
    
};

struct Derived :  public Base{
    int a = 0;
    // Что если новая функция, которая является виртуальной у родителя использует поля наследника
    // Ответ: будет все корректно
    void f() override {std::cout << a;}
    //void f(int) {std::cout << "der";}

private:
    // Доступность функции проверяется в compileTime, а сама функция, которая будет использоваться в runtime
    // Поэтому если мы переопределим виртуальную функцию в приватной части, и вызовем в main, то будет 
    // вызвана функция из дочернего приватного 
    void f(int) {std::cout << "Base_private\n";}
};

struct GrandChild:public Derived{

};

// Есть проблема, которая имеется, когда есть два предка и у каждой есть своя виртуальная функция, которая приведет к неоднозначности 
// 
struct Mom{
    virtual void f() {}
};

struct Dad{
    virtual void f() {}
};

struct Son: public Mom, public Dad
{};

// Пролема в том, что если в наследнике ошибиться с типом, то она будет уже не будет относиться к виртуальной
// а будет уже другой, например, взяли и забыли после сигнатуры const, то будет уже другая функция создаваться, а не виртуальная
// И решением будет использование - override в c++ 11 
// Это позволяет компилятору замечать более, чем он работает без override, когда переопределяйте виртуальную
// функцию 
// Компилятор будет бросать CE если не правильно сделан тип
// Всегда лучше использовать override

// final  -  это слово, которое функция запрещена к переопределению ниже, после сигнатуры и override
// const override final. То есть мы хотим переопределить и запретить дальше наследовать

int main(){
    Son s;
    // s.f(); - будет неоднозначный вызов и будет CE
    // А что будет если у мамы функция виртуальная, а у папы нет

    GrandChild c;
    Derived d;
    Base& b = d; // можно с ссылками и указателями работать
    Base& b3 = c;
    b3.f(0); // Нет версии для GrandChild, то будет пытаться взять как можно частную от подтипа и будет Derived

    Base b1 = d; // так как тут создается новый объект при таком присваивании, то не смотря на виртуальность, будет вызываться базовая реализвция
    
    b1.f(); // Base
    // А что если у нас функция виртуальная, и мы явно  указываем родителя , что хотим из него взять функцию
    // ответ: Будет вызвана функция родителя, хотя виртуальность нам и говорит, что должен быть дочерний
    d.Base::f();// Будет вызвана функция из Base

    d.f(); // Вызовиться Derived. Для ссы
    b.f(); // Вызовиться Base, если мы в его классе не объявим virtual. При определении виртуальной, будет вызван derived. 
}