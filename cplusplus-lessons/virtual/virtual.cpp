#include <iostream>


// Виртуальных конструкторов не может быть так, как они используются перед созданием объекта.
// Идея виартуальной функции - функция, что решение принимается в runtime, она динамическая. 
// Если я скажу,  что функция f  - виртуальная. То всегда будет предпочитаться частный случай функций. Виртуальность распространяется вниз по иеархии наследования
// И данная функция будет всегда замещать своей версией виртуальную функцию. 
// Это будет работать, даже если будет делаться каст (сдвиг указателя) от частного к базовому типу, все равно вызовиться его метод, а не для общего
// Виртуальная функция -  какая версия будет выбрана (с указателями и сслыками тоже будет работать), не будет зависеть от кого будет вызван объект, от родителя или от частного
// Однако, при обычном присваивании, то будет переопределение базового объекта. И будет уже другой объект.
struct Base{ 
    virtual void f() {std::cout << "Base\n";}
};

struct Derived :  public Base{
    void f() {std::cout << "Derived\n";}
};

int main(){
    Derived d;
    Base& b = d; // можно с ссылками и указателями работать

    Base b1 = d; // так как тут создается новый объект при таком присваивании, то не смотря на виртуальность, будет вызываться базовая реализвция
    


    b1.f(); // Base

    d.f(); // Вызовиться Derived. Для ссы
    b.f(); // Вызовиться Base, если мы в его классе не объявим virtual. При определении виртуальной, будет вызван derived. 
}