#include<iostream>

void f(int&) { std::cout << 1 << std::endl; }
void f(const int&) { std::cout << 2 << std::endl; }

int main(){
    // const_cast
    // Не создает нового объекта, а трактурет старый объект по-другому.
    // Использует ссылки на старые объекты, интерпретируя их как const или не как const
    // Поэтому нужно использовать <*> и/или <&> в указании типов, к которому кастуется.
    int x = 0;

    // Если делать от не const к const, то тут нормально делается;
    f(const_cast<const int&>(x));

    // А в обратную сторону уже нет: из const в не const уже плохо
    int n = 5;
    const int& cn = n; // Мы понимаем, что изначальное значение не константа, и поэтому можем исрпавить
    f(const_cast<int&>(cn));

    return 0;
}