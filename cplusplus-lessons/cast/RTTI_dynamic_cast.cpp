#include <iostream>

// Виртуальная функция - это runtime. В реальности, когда обращайтесь к функции, у  которой есть виртуальные объекты
// То компилятор не сразу генерирует код, а сохраняет тип у объекта, и в runtime используется

// Тип, у которого есть хоть бы одна виртуальная функция  -  полиморфный тип.
// Наследник полиморфного типа  -  тоже полиморфный, так как у него есть наследование виртуальной функции.

// Тип, у которого есть хотя бы одна чисто виртуальная функция - абстрактный тип.

// Для полиморфный типов поддерживает runtime type information - чем компилятор снабжает каждый объект полиморфного типа
// Который хранит указатель на эту информацию, в которой указано, что за тип

// Существует оператор, который показывает, что за информацию хранит указатель
// typeid - возвращает объект типа std::typeinfo. У него есть тип name  - строка, которая дает название о функции 
// по объекте возвращает информацию о диначемических типах


struct Base
{
    virtual void f()
    {
        std::cout << "Base\n";
    }
};

struct Derived : public Base
{
    void f() override
    {
        std::cout << "Derived\n";
    }
};

int main(){
    // Статический тип  -  тип, который видит компилятор при компиляции. Тип base
    Derived d;

    Base b;
    int n;
    std::cin >> n; // То есть мы делаем так, чтобы у нас функция от runtime переменной.
    // И тут приходим к определению RTTI.
    // Диначеский тип - во время runtime выполняется, в данном случае - derived
    Base& bb = (n % 2? b : d);

    std::cout << typeid(bb).name() << std::endl; // - запрашиваем информацию(тип) о bb
    std::cout << (typeid(bb) ==  typeid(b)) << std::endl;

    b.f(); // То компилятор должен понять в runtime, то есть в объекте d должна храниться доп информация
    // Если в классе есть виртуальная функция, то вместе с объектом этого типа храниться информация о типе 
    // Поле base или derived - и об этом лежит в vtable
}