#include <iostream>

// Template function overloading

template <typename T, typename U> // Эту функцию можно перегрузить
void f(T x, U u)
{
    std::cout << 1 << std::endl;
}
// ПРичем  перегрузка может быть как шаблонной, так и не шаблонной

template <typename T>
void f(T x, T u) // Работает только с одинаковыми типами, не будет делать каст, в отличии от обычного вызова с частными типами, типа imt, int
{
    std::cout << 2 << std::endl;
}

void f(int x, int u) // Это может скастваться к f(1.1, 1);
{
    std::cout << 3 << std::endl;
}

// Если при вызвое указать f(1), тогда не будет неоднозначности, так как ссылка не может быть иниициализирована rvalue
// Однако если вызвать от 
// int x = 1;
//f(x), то тогда будет проблема с определением функции и программа нескомпилируется
// аналогичсная проблема с const 
template <typename T>
void f(T &x)
{
    std::cout << 4 << std::endl;
}

template <typename T>
void f(T x)
{
    std::cout << 5 << std::endl;
}

// Следующее
// Можно задавать у шаблонов значение по-умолчанию, причем значения по-умолчанию могут идти только последними 

template<typename T, typename U = int>
void h(T x){
    U y;
    std::cout << y << std::endl;
}

// Важно!!!!!!!1 
// Так как точное соответвие предпочтительный навешивание костант
template <typename T>
struct S
{
    S() = default;
    // Конструктор от произвольного типа пререкрывает конструктор от конкретного типа
    template <typename U>
    S(U &x)
    {
        std::cout << 11 << std::endl;
    }

    S(const S<T>&){
        std::cout << 33 << std::endl;
    }
};

int main()
{
    // Частное приведение лучше, чем общее воспринимается компилятором, поэтому в приоритете будет вызваться частное переопределение
    f(1.1, 1);
    f(1, 1);
    f(1.0, 1.0);

    // Все что ниже работает только с шаблонными функциями
    // Можно вызыват функциии с явным указанием шаблонных параметров, тогдав все нормально скастуется, то он не будет рассматривать ее как шаблонную
    f<int>(0.0, 1);  // Вызовается вторая версия функция
    
    
    // Если закоментировать вторую функцию, и потом сделать вызов:
    f<int>(0.0, 1); // То тогда будет каст к первой версии, даже несмотря на то, что функция имеет два конкретных
    // шаблона - можно просто несколько вызывать, а сам догадается что подставить в другие типы

    // Или даже можно вызвать с пустыми скобками - это означает, что я хочу вызвать шаблонную версию
    // А какую именно компилятор сам должен определить
    f<>(0.0, 1);

    // Разница между f<...>(0.0, 1); и f(0.0, 1);, заключается в том, что если мы не указываем <>, то функция рассматривает как частные, так и шалонные, однако,
    // если мы указываем <>, то рассматриваем только шаблонные

    f<>(1, 1); // Тут будет вызвана вторая, так как мы рассматриваем только шаблонные функции, так как указали <>

    S<int> s;
    S<int> ss = s;
}