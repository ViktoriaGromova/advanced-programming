#include <iostream>
#include <cstring>

class String{
    char* str = nullptr;
    size_t size = 0;

public:
    // Если имеется хоть какой-то конструктор копирования/инициализации, то колмпилятор не будет
    // генерировать его по-умолчанию, однако можно его заставить это сделать: 
    String() = default; // явное лучше не явного, проверяйте
    // Инициализация 
    String(size_t size, char ch){
        this->size = size;
        str = new char[size];
    // for(int i = 0; i < size; ++i) {} - не очень эффективно для копирования
    // Если нужно скопировать одну последовательность байтов в другую: 
    // Если для одного символа, то используем memset
    // если несколько, то используем memcpy();
        memset(str, ch, size);
    }


    // Инициалиация с помощью initializer_list. Была введена с C++11
    String(const std::initializer_list<char>& lst){
        size = lst.size();
        str = new char[size];
        std::copy(lst.begin(), lst.end(), str);
    }

    // Можно запретить инициализацию 
    // String() = delete()

    // Консруктор копирования используется, когда хотим один объект скопировать в другой
    // Он может создаваться по умолчанию, однако, это делается по-тупому: копируются все поля
    // Есть два типа копирования: shallow copy и deep copy
    // Shallow  copy копирует указатели, но не копирует отдельно содержимое
    // Deep copy копирует все в отдельное пространоство и переприсваивает

    // shallow copy - по умолчанию
    String(const String&) = default;

    String(const String& string){ // deep copy
        this->size = string.size;
        str = new char[string.size];
        memcpy(str, string.str, size);
    }

    // delegating construction
    // Можно сделать делегирующий конструктор и заменить конструктор выше 
    String(const String& string): String(string.size, 0) // Работаем как раз с другим конструктором
    {
        // и описать только то, что доделать
        memcpy(str, string.str, size);
    }
    

    // Деструктор вызывается, когда объект необходимо уничтожить, и что нужно дополнительно сделать,
    // чтобы уничнтожить все
    ~String(){
        delete[] str;
    // size = 0 - это глупо, так как оно автоматически снимутся со стека;
    // Необходимо сделать так, чтобы только нетривиальную часть очистить;
    }
};

struct S{ // работает, когда все поля публичные 
    int x;
    double y;
    std::string s;
};

int main(){
    // Если реализован хоть какой-то конструктор инициализации/копирования, то по-умолчанию конструктор не будет
    // работать 
    String str(10, 'a');
    // Если не реализован оператор присваивания, то это shallow copy
    String s = str; // Это копироние, которое эквивалетно String s(str)

    // Инициализация с помощью initializer_list
    String ss = {'a', 'b', 'c'};

    // aggregate initialization
    S sw = {0, 1.2, "abx"}; // работает, когда все поля публичные 

    // Как не спутать конструктор копирония с опреатором присваивания
    // Оператор присваивания - это когда используем уже сущствующий объект, и хотим его переопределить
    // а не когда мы создаем и инициализируем его другим объектом 
    return 0;
}