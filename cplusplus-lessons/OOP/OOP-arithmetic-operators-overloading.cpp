#include <iostream>
// Скотт Майерс
// Аналогично далее реализации при умножении/ делении и вычитании
class Complex
{
    double re;
    double im;

public:
    Complex(double im) : re(0.0), im(im) {}
    Complex(double re, double im) : re(re), im(im) {}
    Complex &operator+=(const Complex &c)
    {
        this->re += c.re;
        this->im += c.im;
        return *this;
    }

    // Возвращается новый объект
    // Return value optimization. Когда у нас возвращаемый тип - объект, то мы создаем новый объект, а потом
    // его же возвращайте. Это фича, которая оптимизирует момент, когда вы создаете объект и  тут же его возвращайте
    // то он его не создает его на стеке, а создает его в том регистре, и туда его и кладет.
    // Complex operator+(const Complex &c)
    // {
    //     Complex new_c = *this;
    //     return new_c += c; // При такой реализации будет 2 копирования  -  инициализация нового объекта + возвращение
    // } // Компилятор не понял, что здесь тоже самое значение возвращается.

    Complex operator+(const Complex &c)
    {
        Complex new_c = *this;
        new_c += c;
        return new_c; // При такой реализации будет 1 копирование. Чтобы компилятор видел, что вы создаете и возвращаете одно и тоже значение
    }

    // Инкремент: префиксный и постфиксный
    // Префисный
    Complex &operator++()
    {
        return *this += 1.0;
    }

    // Посфиксный
    //  Создает копию
    Complex operator++(int)
    {
        Complex new_c = *this;
        ++ (*this);
        return new_c;
    }
};

// Оператор + можно реализовать вне класса, тогда его можно будет использовать с двух сторон
// При этом другой оператор внутри класса надо убрать
Complex operator+(const Complex& a, const Complex& b){
    Complex sum = a;
    sum += b;
    return sum;
}

int main()
{
    Complex c(1.0, 2.0);
    Complex cc = c + c; // copy elision Здесь всего лишь у одного объекта вызов
    c + 5.0;
    // Однако, если использовать оператор сложения, который используется в классе, левый операнд - объект класс
    // поэтому работать не будет 5.0 + c
    // Здесь компилятор превращает неявно в c.operator+(5.0)

    // ПОэтому если хотим, чтобы работало равноправно по отношению к левому и правому опреанду
    // то operator+(5.0, c) будет выглядеть вызов

    return 0;
}